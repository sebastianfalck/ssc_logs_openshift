pipeline {
    agent any

    environment {
        REPO_URL         = ''
        REPO_CREDENTIALS = 'github-credentials'
        SERVER_INTERNAL  = 'https://internal.openshift.example:6443'
        SERVER_EXTERNAL  = 'https://external.openshift.example:6443'
        SERVER_DRS       = 'https://drs.openshift.example:6443'
        SENSITIVE_WORDS  = 'password,username,user,token,secret'
    }

    parameters {
        string(name: 'NOMBRE',    defaultValue: '',                   description: 'Nombre del microservicio')
        choice(name: 'AMBIENTE',  choices: ['dev','uat','prd','drs'], description: 'Ambiente')
        choice(name: 'ACCION',
               choices: ['none','get logs','get deployment','describe pod','get quota','get pods','get secrets','get configmaps'],
               description: 'Comando a ejecutar')
    }

    stages {
        stage('Checkout Project') {
            steps {
                dir('project') {
                    git branch: 'main',
                        url: env.REPO_URL,
                        credentialsId: env.REPO_CREDENTIALS
                }
            }
        }

        stage('Leer configuración CSV') {
            steps {
                script {
                    def lines   = readFile('project/ProjectsJenkinsCardifCSV.csv')
                                         .readLines()
                                         .findAll { it.trim() }
                    def headers = lines[0].split(';').collect { it.trim() }
                    def fila = lines.drop(1)
                        .collect { l ->
                            def vals = l.split(';')
                            def m    = [:]
                            headers.eachWithIndex { h,i -> m[h] = (vals.size()>i?vals[i]:'').trim() }
                            m
                        }
                        .find { it.appName == params.NOMBRE }
                    writeFile file: "fila_${params.NOMBRE}.json",
                              text: groovy.json.JsonOutput.toJson(fila)
                }
            }
        }

        stage('Confirmación de país') {
            steps {
                script {
                    def fila    = readJSON file: "fila_${params.NOMBRE}.json"
                    def paisCsv = fila.country?.toLowerCase()
                    def partes  = env.WORKSPACE.split(/[\\/]+/)
                    if (partes.size()<2) error "Ruta demasiado corta: ${env.WORKSPACE}"
                    def paisRuta = partes[-2].toLowerCase()
                    echo "País ruta: ${paisRuta}, país CSV: ${paisCsv}"
                    if (paisCsv != paisRuta) {
                        error "El microservicio no pertenece a tu país: ${paisCsv} vs ${paisRuta}"
                    }
                }
            }
        }

        stage('Ejecutar Acción') {
            when { expression { params.ACCION != 'none' } }
            steps {
                script {
                    def fila      = readJSON file: "fila_${params.NOMBRE}.json"
                    def utils     = new JenkinsUtils(this)
                    def server    = utils.getServer(params.AMBIENTE, fila.usage)
                    def namespace = fila["NameSpace${params.AMBIENTE.capitalize()}"]

                    def sanitize = { text ->
                        def result = text
                        env.SENSITIVE_WORDS.split(',').each { word ->
                            def regex = "(?i)${java.util.regex.Pattern.quote(word.trim())}"
                            result = result.replaceAll(regex, '****')
                        }
                        return result
                    }

                    wrap([$class: 'MaskPasswordsBuildWrapper',
                          varPasswordPairs: [[var: 'TOKEN', password: fila["Token${params.AMBIENTE.capitalize()}"]]]]) {
                        sh utils.getOcLoginCmd(server, env.TOKEN)

                        def salida

                        switch (params.ACCION) {
                            case 'get logs':
                                def pod = utils.getPodName(namespace, params.NOMBRE)
                                echo "Pod: ${pod}"
                                utils.getLogs(pod, namespace, params.NOMBRE, params.AMBIENTE)
                                salida = readFile('reporte.html')
                                break
                            case 'get deployment':
                                def deployment = utils.getDeploymentName(namespace, params.NOMBRE)
                                echo "Deployment: ${deployment}"
                                utils.getDeploymentYaml(deployment, namespace, params.NOMBRE, params.AMBIENTE)
                                salida = readFile('reporte.html')
                                break
                            case 'describe pod':
                                def pod = utils.getPodName(namespace, params.NOMBRE)
                                echo "Pod: ${pod}"
                                utils.getDescribePod(pod, namespace, params.NOMBRE, params.AMBIENTE)
                                salida = readFile('reporte.html')
                                break
                            case 'get quota':
                                utils.getQuota(namespace, params.NOMBRE, params.AMBIENTE)
                                salida = readFile('reporte.html')
                                break
                            case 'get pods':
                                utils.getPods(namespace, params.NOMBRE, params.AMBIENTE)
                                salida = readFile('reporte.html')
                                break
                            case 'get secrets':
                                if (['qa', 'prd'].contains(params.AMBIENTE)) {
                                    input message: "¿Aprobar acceso a secrets de ${params.AMBIENTE} para el microservicio ${params.NOMBRE}?",
                                          ok: 'Aprobar',
                                          submitter: 'admin1,admin2'
                                }
                                utils.extractSecret(namespace, params.NOMBRE, params.AMBIENTE)
                                salida = sanitize(readFile('reporte.html'))
                                break
                            case 'get configmaps':
                                utils.extractConfigMap(namespace, params.NOMBRE, params.AMBIENTE)
                                salida = sanitize(readFile('reporte.html'))
                                break
                        }

                        wrap([$class:'BuildUser']) {
                            emailext(
                                to: env.BUILD_USER_EMAIL,
                                subject: "${params.ACCION} ${params.NOMBRE} - ${params.AMBIENTE}",
                                body: salida
                            )
                        }

                        sh utils.getOcLogoutCmd()
                    }
                }
            }
        }
    }
}

// ======= JenkinsUtils.groovy helper =========

class JenkinsUtils {
    def steps
    JenkinsUtils(steps) { this.steps = steps }

    def getServer(ambiente, tipoAcceso) {
        def serverMap = [
            'drs'     : { -> steps.env.SERVER_DRS },
            'internal': { -> steps.env.SERVER_INTERNAL },
            'external': { -> steps.env.SERVER_EXTERNAL }
        ]
        if (ambiente?.toLowerCase() == 'drs') return serverMap['drs']()
        def key = tipoAcceso?.toLowerCase()
        return serverMap.get(key, serverMap['internal'])()
    }

    def getOcLoginCmd(server, token) {
        return "oc login --insecure-skip-tls-verify --server=${server} --token=${token}"
    }

    def getOcLogoutCmd() {
        return "oc logout"
    }

    def getPodName(namespace, nombre) {
        return steps.sh(
            script: "oc get pod -n ${namespace} | grep '${nombre}-.*' | awk '{print \$1}' | head -n1",
            returnStdout: true
        ).trim()
    }

    def getLogs(pod, namespace, nombre, ambiente) {
        steps.sh "oc logs ${pod} -n ${namespace} > ${pod}.log"
        steps.sh "python logs.py ${pod}.log ${nombre} ${ambiente} logs"
    }

    def getDeploymentName(namespace, nombre) {
        return steps.sh(
            script: "oc get deployment -n ${namespace} | grep '${nombre}' | awk '{print \$1}'",
            returnStdout: true
        ).trim()
    }

    def getDeploymentYaml(deployment, namespace, nombre, ambiente) {
        steps.sh "oc get deployment ${deployment} -n ${namespace} -o yaml > deployment.yaml"
        steps.sh "python logs.py deployment.yaml ${nombre} ${ambiente} deployment"
    }

    def getDescribePod(pod, namespace, nombre, ambiente) {
        steps.sh "oc describe pod ${pod} -n ${namespace} > describe.txt"
        steps.sh "python logs.py describe.txt ${nombre} ${ambiente} describe"
    }

    def getQuota(namespace, nombre, ambiente) {
        steps.sh "oc get resourcequota -n ${namespace} -o yaml > quota.yaml"
        steps.sh "python logs.py quota.yaml ${nombre} ${ambiente} quota"
    }

    def getPods(namespace, nombre, ambiente) {
        steps.sh "oc get pods -n ${namespace} -o wide > pods.txt"
        steps.sh "python logs.py pods.txt ${nombre} ${ambiente} pods"
    }

def extractSecret(namespace, nombre, ambiente) {
    steps.sh """
        oc get secret ${nombre} -n ${namespace} -o json | jq -r '.data | to_entries[] | "\\(.key)=\\(.value | @base64d)"' > secret.env
    """
    steps.sh "python logs.py secret.env ${nombre} ${ambiente} env"
}

def extractConfigMap(namespace, nombre, ambiente) {
    steps.sh """
        oc get configmap ${nombre} -n ${namespace} -o json | jq -r '.data | to_entries[] | "\\(.key)=\\(.value)"' > configmap.env
    """
    steps.sh "python logs.py configmap.env ${nombre} ${ambiente} env"
}


}
